import { EncoderOverrides, ContractFunctionObj, ContractTxFunctionObj, BaseContract } from '@0x/base-contract';
import { ContractAbi, TxData, SupportedProvider } from 'ethereum-types';
import { BigNumber } from '@0x/utils';
export declare class WyvernExchangeV1Contract extends BaseContract {
    /**
     * @ignore
     */
    static deployedBytecode: string | undefined;
    static contractName: string;
    private readonly _methodABIIndex;
    /**
     * @returns      The contract ABI
     */
    static ABI(): ContractAbi;
    getFunctionSignature(methodName: string): string;
    getABIDecodedTransactionData<T>(methodName: string, callData: string): T;
    getABIDecodedReturnData<T>(methodName: string, callData: string): T;
    getSelector(methodName: string): string;
    INVERSE_BASIS_POINT(): ContractFunctionObj<BigNumber>;
    approveOrder(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, orderbookInclusionDesired: boolean): ContractTxFunctionObj<void>;
    approvedOrders(index_0: string): ContractFunctionObj<boolean>;
    atomicMatch(buy: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, buySig: {
        v: number | BigNumber;
        r: string;
        s: string;
    }, sell: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, sellSig: {
        v: number | BigNumber;
        r: string;
        s: string;
    }, metadata: string): ContractTxFunctionObj<void>;
    calculateCurrentPrice(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<BigNumber>;
    calculateFinalPrice(side: number | BigNumber, saleKind: number | BigNumber, basePrice: BigNumber, extra: BigNumber, listingTime: BigNumber, expirationTime: BigNumber): ContractFunctionObj<BigNumber>;
    calculateMatchPrice(buy: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, sell: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<BigNumber>;
    cancelOrder(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, sig: {
        v: number | BigNumber;
        r: string;
        s: string;
    }): ContractTxFunctionObj<void>;
    cancelledOrFinalized(index_0: string): ContractFunctionObj<boolean>;
    changeDevWalletAddress(newDevWalletAddress: string): ContractTxFunctionObj<void>;
    changeMinimumMakerProtocolFee(newMinimumMakerProtocolFee: BigNumber): ContractTxFunctionObj<void>;
    changeMinimumTakerProtocolFee(newMinimumTakerProtocolFee: BigNumber): ContractTxFunctionObj<void>;
    changeProtocolFeeRecipient(newProtocolFeeRecipient: string): ContractTxFunctionObj<void>;
    codename(): ContractFunctionObj<string>;
    devWallet(): ContractFunctionObj<string>;
    exchangeToken(): ContractFunctionObj<string>;
    guardedArrayReplace(array: string, desired: string, mask: string): ContractFunctionObj<string>;
    hashOrder(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<string>;
    hashToSign(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<string>;
    initialize(registryAddress: string, tokenTransferProxyAddress: string, tokenAddress: string, protocolFeeAddress: string, devWalletAddress: string): ContractTxFunctionObj<void>;
    minimumMakerProtocolFee(): ContractFunctionObj<BigNumber>;
    minimumTakerProtocolFee(): ContractFunctionObj<BigNumber>;
    name(): ContractFunctionObj<string>;
    orderCalldataCanMatch(buyCalldata: string, buyReplacementPattern: string, sellCalldata: string, sellReplacementPattern: string): ContractFunctionObj<boolean>;
    ordersCanMatch(buy: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, sell: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<boolean>;
    owner(): ContractFunctionObj<string>;
    protocolFeeRecipient(): ContractFunctionObj<string>;
    registry(): ContractFunctionObj<string>;
    renounceOwnership(): ContractTxFunctionObj<void>;
    staticCall(target: string, calldatas: string, extradata: string): ContractFunctionObj<boolean>;
    testCopy(arrToCopy: string): ContractFunctionObj<string>;
    testCopyAddress(addr: string): ContractFunctionObj<string>;
    tokenTransferProxy(): ContractFunctionObj<string>;
    transferOwnership(newOwner: string): ContractTxFunctionObj<void>;
    validateOrder(hash: string, order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }, sig: {
        v: number | BigNumber;
        r: string;
        s: string;
    }): ContractFunctionObj<boolean>;
    validateOrderParameters(order: {
        exchange: string;
        maker: string;
        taker: string;
        makerRelayerFee: BigNumber;
        takerRelayerFee: BigNumber;
        makerProtocolFee: BigNumber;
        takerProtocolFee: BigNumber;
        feeRecipient: string;
        feeMethod: number | BigNumber;
        side: number | BigNumber;
        saleKind: number | BigNumber;
        target: string;
        howToCall: number | BigNumber;
        calldatas: string;
        replacementPattern: string;
        staticTarget: string;
        staticExtradata: string;
        paymentToken: string;
        basePrice: BigNumber;
        extra: BigNumber;
        listingTime: BigNumber;
        expirationTime: BigNumber;
        salt: BigNumber;
        dataType: string;
        data: string;
    }): ContractFunctionObj<boolean>;
    version(): ContractFunctionObj<string>;
    constructor(address: string, supportedProvider: SupportedProvider, txDefaults?: Partial<TxData>, logDecodeDependencies?: {
        [contractName: string]: ContractAbi;
    }, deployedBytecode?: string | undefined, encoderOverrides?: Partial<EncoderOverrides>);
}
